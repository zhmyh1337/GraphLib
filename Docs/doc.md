# GraphLib
Примитивная шаблонная библиотека, позволяющая работать с графами.

## Установка
Для включения библиотеки в проект, необходимо подключить заголовочный файл *Graph.h*. Остальное подключать не обязательно.

## Использование
### Интерфейс
Все содержимое библиотеки находится в пространстве имен `graph`. Пользовательский интерфейс состоит из класса `Graph`,
а также классов, описывающих модель хранения графов и/или инициализирующих их (в дальнейшем — контейнеры графов). Контейнеры графов реализуют интерфейс `IGraphContainer`,
и такими классами являются: `AdjacencyList`, `AdjacencyMatrix`, `EdgeList`.

### Создание графа
Поддерживаются как взвешенные, так и невзвешенные графы. Класс `Graph`, а также контейнеры графов принимают в качестве шаблонных параметров
тип вершины (`VertexType`) и тип весов ребер (`WeightType`). Для того, чтобы граф был невзвешенным,
необходимо `WeightType = void`. По умолчанию шаблонный параметр `WeightType` имеет значение `void`, т. е. граф невзвешенный.

### Тип ребер
Для работы с графом понадобится использовать тип ребер (`EdgeType`). Для невзвешенных графов `EdgeType = VertexType`,
для взвешенных `EdgeType = std::pair<VertexType, WeightType>`.

### Конструкторы графа
Класс `Graph` имеет конструктор без аргументов: в таком случае создастся пустой граф на основе `AdjacencyList`.
Также он имеет конструктор от аргумента `IGraphContainer<VertexType, EdgeType>`, т. е. можно задать свою модель хранения,
а также инициализировать начальные ребра.

### Контейнеры графов
Каждый контейнер графов имеет конструктор без аргументов: в таком случае создается пустой граф на основе этого контейнера.
#### `AdjacencyList`
Этот контейнер графов также имеет конструктор от `std::unordered_map<VertexType, std::vector<EdgeType>>`, т. е. в качестве ключа словаря выступает
вершина, а в качестве значения — контейнер ребер.  
Пример создания (невзвешенный граф):
```c++
new graph::AdjacencyList<int>({
    { 1, { 2, 3, 5 }},
    { 2, { 1, 2, 3 }},
    { 6, { 1 }},
});
```

#### `AdjacencyMatrix`
Этот контейнер графов, помимо обязательного шаблонного параметра `VertexType` и необязательного `WeightType`, принимает первым шаблонный параметр
`size_t MaxVertexIndex`, который определяет размер матрицы смежности. Помимо этого, `VertexType` должен быть конвертируем в `size_t`, т. к.
при работе с матрицей смежности вершина будет выступать в качестве индекса в этой матрице. Таким образом, если во время исполнения вершина выйдет за
границу `MaxVertexIndex`, это может привести к ошибке исполнения или UB.
Для невзвешенных графов этот контейнер графов имеет конструктор от `std::array<std::array<size_t, MaxVertexIndex>, MaxVertexIndex>` (двумерный массив, где
в качестве элементов выступает количество ребер между двумя вершинами (т. к. они могут быть кратными)).
Для взвешенных графов этот контейнер графов имеет конструктор от `std::array<std::array<std::vector<WeightType>, MaxVertexIndex>, _MaxVertexIndex>`
(в качестве элементов выступает контейнеров весов ребер между двумя вершинами).  
Пример создания (невзвешенный граф):
```c++
auto structure = new graph::AdjacencyMatrix<3, int>({
    std::array<size_t, 3>
    { 0, 1, 0 },
    { 1, 1, 0 },
    { 2, 0, 0 },
});
```

#### `EdgeList`
Этот контейнер графов также имеет конструктор от `std::vector<std::pair<VertexType, EdgeType>>`, т. е. контейнер ребер.  
Пример создания (взвешенный граф):
```c++
auto structure = new graph::EdgeList<int, double>({
   std::make_pair(-1, std::make_pair(5, 25.0)),
   std::make_pair(5, std::make_pair(1, 5.5)),
   std::make_pair(3, std::make_pair(6, 13.0)),
   std::make_pair(6, std::make_pair(3, 6.4)),
   std::make_pair(3, std::make_pair(7, 2.4)),
   std::make_pair(3, std::make_pair(6, 5.0)),
   std::make_pair(0, std::make_pair(0, 0.0)),
});
```

### Функционал
#### Добавление ребер
Для добавления ребер в граф можно использовать методы `AddEdge` (однонаправленное) и `AddBidirectionalEdge` (двунаправленное).  
Пример (добавить в граф `graph` ребро однонаправленное ребро весом 22.0f из вершины 0 в вершину 2):
```c++
graph.AddEdge(0, std::make_pair(2, 22.0f));
```

#### Получение списка ребер
Для получения списка ребер используется метод `std::vector<EdgeType> GetAllEdgesOfVertex(VertexType vertex)`.
Пример (получить список ребер из вершины 0):  
```c++
auto edges = graph.GetAllEdgesOfVertex(0);
```

#### Итерация по вершинам
Поддерживаются `DepthFirstSearch` и `BreadthFirstSearch `(поиск в глубину и в ширину). Сигнатуры методов одинаковы:
```c++
void BreadthFirstSearch(VertexType startingVertex, std::function<void(VertexType, EdgeType)> callback) const
```
Где `startingVertex` - начальная вершина, `callback` - callback, который будет вызываться при переходе в новую вершину по ребру.  
**Оба алгоритма не будут идти в уже посещенную вершину.**  
Пример (вывод пути в DFS из вершины 0):
```c++
graph.DepthFirstSearch(0, [](int from, int to) { std::cout << from << " -> " << to << std::endl; });
```

## Примеры
Доступно 4 проекта с примерами в папке Samples.

### GraphIteration
Демонстрирует итерацию по вершинам с использованием BFS и DFS как для взвешенного, так и для невзвешенного графа.

### Visitor
Демонстрирует работу паттерна "Посетитель" на графе.

### Composite
Демонстрирует работу паттерна "Компоновщик" на графе.

### GraphInitialization
Показывает различные способы инициализации графа.
